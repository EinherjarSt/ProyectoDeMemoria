%% inicio, la clase del documento es iccmemoria.cls
\documentclass{iccmemoria}
\usepackage[onelanguage, commentsnumbered, linesnumbered, boxed, ruled]{algorithm2e}
\usepackage{pdfpages}
\usepackage{amsfonts}
\usepackage{amssymb}

%% datos generales y para la tapa
\titulo{Herramienta para la optimización de redes de distribución de agua potable}
\author{Gabriel Gonzalo Alexander Sanhueza Fuentes}
\supervisor{Jimmy Gutierrez Bahamondes}
\cosupervisor{Daniel Mora Melia}
\informantes
	{Profesor Informante 1}
	{Profesor Informante 2}
\adicional{(sólo por si se necesita agregar algún otro profesor)}
\director{Profesor del ramo Memoria de Título}
\date{mes, año}

%% inicio de documento
\begin{document}

%% crea la tapa
\maketitle

%% dedicatoria
\begin{dedicatory}
Dedicado a ...
\end{dedicatory}

%% agradecimientos
\begin{acknowledgment}
Agradecimientos a ...
\end{acknowledgment}

%% indices
\tableofcontents
\listoffigures
\listoftables

%% resumen
\begin{resumen}
La escasez de agua potable es un problema a nivel mundial. Cada día aumenta la necesidad de utilizar eficientemente los recursos hídricos disponibles. Sin embargo, la optimización de todos los procesos involucrados en su gestión es una tarea compleja. Especialmente, la distribución del agua es un procedimiento difícil de optimizar debido a que implica el modelamiento de variables físicas que se relacionan de manera no lineal \cite{Basha1996}. Diversos investigadores han abordado el problema desde diferentes perspectivas. Donde una gran cantidad de trabajos ha destacado a los algoritmos metaheurísticos como herramientas eficientes frente a la resolución de problemas complejos de esta área. Debido principalmente a su capacidad de exploración del espacio de posibles soluciones en tiempos razonables. A pesar de ello, existen muy pocos sistemas computacionales que permitan a los ingenieros hidráulicos optimizar el diseño y operación de las redes de distribución de agua (RDA) desde una interfaz gráfica, sin tener que codificar.  

Es por ello que este proyecto busca llevar a cabo el desarrollo de una herramienta que permita la optimización de problemas presentes en RDA. En términos generales, el objetivo es diseñar e implementar una aplicación de escritorio que pueda ser utilizada por personas interesadas en la labores del diseño y operaciones de RDA. A pesar de que existe muchos problemas relacionados con esta temática, este proyecto se centrará en dos. Los cuales han sido seleccionados por un grupo de expertos que apoya este proyecto. El primero corresponde a la optimización del diseño de RDA basado en la minimización del costo de inversión según la selección de diámetros de tuberías. En segundo lugar, el problema de planificaciones de las operaciones de los sistemas de bombeo que optimiza simultáneamente los costos energéticos y de mantenimiento de los equipos. Para ello, el proyecto contempla la implementación de un Algoritmo Genético (GA) \cite{Heiss-Czedik1997} para la resolución de problemas monoobjetivos, el algoritmo  "Nondominated Sorting Genetic Algorithm II" (NSGA-II) \cite{Deb2002} para el caso de problemas multiobjetivos y todos los métodos que permiten realizar las simulaciones hidráulicas de RDA.

Adicionalmente, es importante destacar que este nuevo sistema debe poseer una arquitectura escalable que sirva como base para la adición de nuevos problemas y algoritmos a medida que sean requeridos.

A continuación se presentan los conceptos básicos que son necesarios para el desarrollo de este proyecto. Posteriormente, se presenta el problema y contexto del proyecto. Finalmente, se presenta la propuesta de solución al problema identificado.

Para el desarrollo de este proyecto se opto por utilizar la metodología de desarrollo Iterativo e Incremental.

Para la evaluación del sistema a desarrollar se usara la metodología de caso de estudio cuyo resultado permitirá determinar la utilidad del software desarrollado. 
\end{resumen}

%% abstract

%% contenido del primer capítulo
\chapter{Introducción}
Este capítulo tiene como objetivo presentar el contexto, el problema, la propuesta de solución, los objetivos y el alcance del proyecto. Así como también, entregar antecedentes sobre los trabajos relacionados al tema.
\section{Contexto del proyecto} 
La escasez de agua potable es sin duda una problemática a nivel mundial y la optimización de los sistemas que permiten su distribución es cada día más relevante. Existe una serie de problemáticas asociadas a la determinación de las condiciones óptimas de operaciones y las características adecuadas para su construcción.
Las RDA son redes que pueden ser muy extensas y complejas. Forman parte de la estructura principal de cualquier ciudad. Deben ser capaces de adaptarse a los cambios y asegurar niveles mínimos de servicios durante las 24 horas del día \cite{Pereyra2017}. Adicionalmente, dependiendo de su topología, las RDA integran sistemas de bombeo que requieren gran cantidad de energía en horarios determinados.

La optimización de estos sistemas, a la vez, involucra la participación de múltiples criterios que deben ser tomados en cuenta a la hora de decidir. Sin embargo, la incorporación de éstos, involucra la generación de modelos cada vez más complejos \cite{JHawanet-2019}.

Por lo anteriormente mencionado, esta área, ha llamado la atención de muchos investigadores que han creado diversos métodos para resolver la problemática desde diferentes enfoques. Sin embargo, aún existen muy pocas aplicaciones computacionales que permitan emplear los nuevos modelos y técnicas de forma práctica. Esto supone un gran problema para los interesados en aplicar estos conocimientos en un contexto real. Generalmente se trata de personas instruidas en temáticas relacionadas con la hidráulica pero que poseen un escaso manejo de técnicas computacionales de optimización.

En este trabajo se pretende dar respuesta a esa necesidad creciente a través del diseño e implementación de una aplicación de escritorio. Este nuevo sistema, permitirá a a los usuarios resolver dos de los principales problemas en la optimización de RDA. Para ello utilizará un algoritmo genético, en el caso de los problemas con solo un objetivo y NSGA-II para resolver problemas del tipo multiobjetivo.

\section{Presentación del problema}

Los encargados de implementar sistemas de distribución de agua potable, no cuentan con suficientes herramientas y tiempo para su correcta gestión. Por lo tanto, no es posible utilizar los recursos asociados de forma eficiente. Además, las herramientas existentes no satisfacen las necesidades de usabilidad y costo, debido a que son poco intuitivas y de pago.

El escoger las especificaciones de una red de agua potable es una tarea difícil debido a que hay que evaluar el rendimiento general del sistema en función de un conjunto de variables que se mueven en un rango muy elevado de posibilidades. Debido a esto, el uso de herramientas que optimicen la selección de estas características puede ayudar considerablemente a reducir costos operaciones y de inversión.

Finalmente, es importante destacar que la construcción de un sistema que permita realizar la optimización de RDA es compleja. Necesita del conocimiento técnico de expertos en el área de hidráulica y computación. Involucra el trabajo con programas de simulación computacional que modelan las características de los sistema de agua bajo presión y de algoritmos metaheurísticos que los subordinen.   


%\section{Hipótesis}

\section{Objetivos}
Para abarcar la problemática se fijan los siguientes objetivos
\subsubsection{Objetivo general}
\begin{itemize}
	%\item Desarrollar un sistema web que permita administrar la asignación de salas de clase de forma automática y eficiente.
	\item Diseñar y desarrollar una aplicación de apoyo a la toma de decisiones, integrando algoritmos de optimización aplicados al problema de diseño y operación en redes de distribución de agua potable.
\end{itemize}
\subsubsection{Objetivos especificos}
\begin{enumerate}
	\item Generar soluciones frente al problema monoobjetivo de diseño de redes de distribución de agua potable a través de la implementación de algoritmos genéticos.
	\item Generar soluciones frente al problema multiobjetivo de operación de redes de distribución de agua potable a través de la implementación de NSGA-II.
	\item Diseñar he implementar la interfaz gráfica del sistema de optimización de redes de agua potable desarrollado durante este proyecto.
	\item Evaluar el desempeño de los algoritmos, contrastando los resultados obtenidos en redes de benchmarking con óptimos conocidos.
\end{enumerate}

\section{Propuesta de solución}
La solución que se propone para abordar el problema consiste en el desarrollo de una aplicación que 
que permita buscar soluciones a dos de los problemas existentes en las redes de agua potable. Además, de hacer uso de una arquitectura que permita fácilmente extender el programa para abarcar nuevos problemas. Para lograr esto último la aplicación debe quedar bien documentada. Por lo tanto, lo que se tendrá al termino del desarrollo del proyecto será un software escalable que tratara con dos problemas relacionados a la distribución de agua potable y que podrá ser ampliado en futuros trabajos.

Los problemas que se abordaran en el contexto de optimización de redes de agua potable serán:
\begin{itemize}
	\item \textbf{Problema de diseño:} Se trata este problema desde un enfoque monoobjetivo implementando un algoritmo genético que buscará la optimización de los costo de inversión variando el diámetro de las tuberías. 
	\item \textbf{Problema de operación:} Este problema se abordara desde el enfoque multiobjetivo. Para esto se implementara el algoritmo NSGA-II y se buscará la optimización de los objetivos de costos energéticos y el número de encendidos y apagados de las bombas.
\end{itemize}

Tanto el algoritmo genético como el NSGA-II, permiten la utilización de distintos operadores de cruzamiento y mutación que también serán implementados para ser utilizados. 

La solución planteada supone además el diseño e implementación de una interfaz gráfica para ayudar al usuario en el uso de la herramienta.

\section{Alcances}
Los alcances propuestos para este proyecto serán los siguientes:
\begin{itemize}
	
	\item El sistema permitirá la carga y la visualización de la red gráficamente.
	\item El sistema permitirá visualizar la configuración básica almacenada en el archivo inp de los elementos de la red.
	\item El sistema solo resolverá dos clases de problemas de optimización, uno monoobjetivo y el otro multiobjetivo. El problema monoobjetivo será el de los costos de inversión. En cuanto al problema multiobjetivo, este será el de los costos energéticos y el número de encendidos y apagado de las bombas. 
	\item El sistema únicamente contara con dos algoritmos implementados los cuales serán el algoritmo genético y NSGA-II. El algoritmo genético será el usado para tratar el problema monoobjetivo, mientras que NSGA-II será aplicado al multiobjetivo.
	\item El sistema permitirá visualizar el o los resultados obtenidos al finalizar la ejecución del algoritmo.
	\item El sistema permitirá generar archivos .inp con la configuración de la solución obtenida a través de los algoritmos. Debido a que el archivo .inp establece una gran cantidad de configuraciones, las únicas que se permitirán modificar serán las configuraciones asociadas a los conexiones (junctions) y tuberías (pipes).
	\item El sistema permitirá generar archivos con las soluciones obtenidas para cada problema, es decir, el valor de los objetivos y las variables de decisión involucradas.
	\item El sistema permitirá graficar visualmente las soluciones en un plano cartesiano.
	\item La gráfica únicamente estará disponible en problemas con uno o dos objetivos.
	\item La comparación con las redes de benchmarking consistirá únicamente, en presentar una tabla comparativa entre los resultados presentes en la literatura y los obtenidos a través de nuestro sistema, para cada uno de los problemas de redes de distribución de agua potable de nuestro sistema.
	
\end{itemize}
Este proyecto no contempla la creación de la red por lo que estas deberán ser ingresadas como entradas al programa, es decir, estas deberán ser creadas usando EPANET o manualmente, pero siguiendo el formato establecido por EPANET. Además, esta herramienta únicamente podrá ser ocupada en equipos cuyo sistema operativo sea Windows debido a que se realizan llamadas a librerías nativas.
\section{Trabajo relacionado}
En este apartado se mostrarán distintas herramientas y el enfoque utilizado para resolver el problema con ellas. En general, los enfoques consisten en usar software ya disponible o crear un software personalizado.

\begin{itemize}
	\item \textbf{Magmoredes}: En \cite{Edwin2017} se describe la existencia de un software de diseño basado en micro-algoritmos genéticos multiobjetivos, que de acuerdo al autor, tiene un mejor rendimiento y es más eficiente que el algoritmo NSGA-II. Esto se debe a que requiere una menor cantidad de memoria y tiene un mejor tiempo de cómputo. Este programa puede cargar cualquier red y realiza los cálculos utilizando librerías de java. Las funciones objetivos que este sistema intenta resolver son la optimización de los costo y la confiabilidad final de la red.
	
	\item \textbf{WaterGEMS}: Software comercial que permite la construcción de modelos geoespaciales; optimización de diseño, ciclos de bombeo y calibración automática del modelo; y la gestión de activos. Este software a sido usado en \cite{Mehta2017} para llevar a cabo las simulaciones necesarias para su estudio. La metodología seguida para la utilización de este sistema consiste en ingresar los datos a WaterGEMS para correr las simulaciones. La limitación de este programa es que no permite la adición de nuevos algoritmos por parte del usuario, en el caso de que se quiera probar o mejorar algún algoritmo ya existente. Sin embargo, este sistema también tiene sus ventajas, porque ya incorpora algunos algoritmos predefinidos para resolver ciertos problemas. Además, de que cuenta con diversas funcionalidades como conexión con datos externos, operaciones de análisis espaciales, intercambio de datos con dispositivos o programas de administración, entre otros.
	
	\item \textbf{EPANET}: El enfoque seguido con la utilización de esta herramienta consiste en la automatización al momento de ejecutar los algoritmos y la posterior evaluación de los resultados utilizando la librería EPANET Toolkit. Este es usado en \cite{Doctoral2012} y consiste en la creación de un programa el cual implementa algoritmos metaheurísticos y los resultados obtenidos por estos son enviados a la EPANET Toolkit para evaluar la solución y determinar la factibilidad de ésta. La ventaja de este enfoque es que permite una mayor flexibilidad en los algoritmos metaheuristicos utilizados y los problemas que se quieren resolver. Sin embargo, debido a que se necesita implementar los problemas y los algoritmos, este enfoque toma mucho tiempo.
\end{itemize}

Para el desarrollo de este proyecto se usa el enfoque basado en EPANET, puesto que es una librería de simulación hidráulica ampliamente utilizada y permite enfocarnos en la resolución de los problemas usando algoritmos metaheurísticos. Tanto Magmoredes como WaterGEMS buscan resolver temas concretos en los sistemas de distribución de agua potable y puesto que el código de estos programas no esta disponible públicamente o son un sistema que se comercializa sin permitir la modificación del sistema por parte de terceros, se busca con nuestro proyecto incorporar esta capacidad para que en futuros trabajos se pueda abarcar una mayor cantidad de problemas con nuestro sistema.
%% contenido del segundo capítulo
\chapter{Marco Teórico}
En este capítulo se presentan los conceptos que serán necesarios para la realización del proyecto.

\section{Metodología de desarrollo}
Para el desarrollo de este proyecto se opto por la metodología iterativo e incremental. La elección de esta metodología se debe al hecho de que este genera suficiente documentación para ser utilizada en el desarrollo de futuros proyectos derivados de este trabajo.
\subsection{Metodología iterativo e incremental}
El desarrollo iterativo e incremental es una metodología la cual lleva a cabo el desarrollo de un proyecto de software dividiéndolo en iteraciones que generan un incremento, el cual contribuye en el desarrollo del producto final.

Cada iteración se compone de las fases de análisis, diseño, implementación y testing como se muestra en la Figura \ref{fig:methodie}. La fase de análisis se encarga de llevar a cabo la obtención y definición de los requerimientos del software. Durante la etapa de diseño se realiza la conceptualización del software basado en los requerimientos definidos anteriormente. Durante la implementación se codifican las funcionalidades siguiendo las directivas establecidas durante el diseño, con el fin de satisfacer los requerimientos. Y finalmente, durante la fase de testing, se valida y verifica la correctitud de las funcionalidades implementadas, así como el cumplimiento de los requisitos.

\begin{figure}[h]
	\includegraphics{iedevelopment.eps}
	\centering
	\caption{Metodología iterativo e incremental \cite{Pressman2009}}
	\label{fig:methodie}
\end{figure}

El hecho de llevar a cabo un desarrollo iterativo permite la obtención de retroalimentación del producto que se esta desarrollando tempranamente y de esta manera poder refinar el trabajo en etapas posteriores del desarrollo. \cite{Victor2003, Mitchell2009, Martin1999,Alshamrani2015}.

\section{Metodología de evaluación}
\subsection{Casos de estudio}
Un caso de estudio \cite{Runeson2009} es una metodología de investigación la cual en ingeniería de software permite analizar un proyecto, un grupo de personas, un producto, etc, en un contexto real con el objetivo de responder la pregunta de investigación planteada. Esta metodología de evaluación considera aspectos formales para obtener evidencia. Los principales aspectos son:

\begin{itemize}
	\item Describir el contexto de aplicación del caso: Consiste en establecer sobre que elemento se aplicara el caso de estudio a desarrollar.
	\item Definición de objetivos experimentales: Consiste en indicar cual es el objetivo de la investigación a realizar, si es describir, evaluar o explicar algún suceso.
	\item Definición de un protocolo para conducir el caso de estudio: Consiste en escoger las pautas para llevar a cabo el caso de estudio, que instrumentos serán utilizados para recolectar datos y como se realizaran el análisis de estos.
	\item Definición de características a evaluar: Consiste en establecer que es lo que estamos interesados en evaluar del elemento sobre el que se aplica el caso de estudio.
	\item Definición de sujetos de prueba: Consiste en indicar cual sera la fuente de datos a ser utilizada para el caso de estudio, estas pueden ser personas, datos ya recolectados, etc.
	\item Aplicación de caso de estudio en un conjunto de sesiones no controladas: Consiste en llevar a cabo el caso de estudio sobre los sujeto de prueba definidos.
	\item Aplicación de herramientas de obtención de evidencia empírica: Consiste en la utilización de métodos o técnicas con el fin de obtener evidencia empírica a partir de los datos recolectados 	
	\item Análisis y evaluación de datos empíricos: Consiste en analizar la evidencia y evaluar la validez de los resultados obtenidos.
\end{itemize}

\section{Herramientas para la implementación del software}
\subsubsection{Java}
Java es un lenguaje de programación de alto nivel orientado a objetos y de propósito general. Un programa java se ejecuta sobre la maquina virtual llamada la Java Virtual Machine, la cual le da a este lenguaje la característica de ser multiplataforma. Adicionalmente, java incorpora el soporte para multi-hilos, una poderosa herramienta que permite la ejecución de distintas instrucciones de código al mismo tiempo \cite{Gosling2015}. Ademas. este lenguaje también incorpora una característica conocida como el recolector de basura, el cual se encarga de limpiar la memoria de objetos que ya no están siendo utilizados.  Fue anunciado por Sun Microsystems en Mayo de 1995 \cite{3java}. 

\subsubsection{Java Reflection}
Característica de java que permite que un programa se auto examine. Esta característica está disponible a través de la Java Reflection API, la cual cuenta con métodos para obtener los meta-object de las clases, métodos, constructores, campos o parámetros. Esta API también permite crear nuevos objetos cuyo tipo era desconocido al momento de compilar el programa \cite{Braux1999}.
\subsubsection{Java Annotation}
Característica de java para agregar metadatos a elementos de java (clases, métodos, parámetros, etc.) [7]. Las anotaciones no tienen efecto directo sobre el código, pero cuando son usadas junto con otras herramientas pueden llegar a ser muy útiles. Estas herramientas pueden analizar estas anotaciones y realizar acciones en base a estas, por ejemplo, generar archivos adicionales como clases de java, archivos xml, entre otras; ser analizadas durante la ejecución del programa vía Java Reflection, para crear objetos cuyo tipo no conocemos en tiempo de compilación; etc. 
\section{Red de distribución de agua potable}
Conjunto de elementos enlazados de tal manera que permite suministrar cierta cantidad de agua a una presión establecida \cite{Doctoral2012}.

\subsubsection{Caudal}
Cantidad de agua que se mueve a través de un segmento de la red.

\subsection{Componentes físicos de una red}
A continuación se define los componentes que conforman una red de agua potable \cite{Rossman2017}, los cuales se aprecian en la Figura \ref{fig:componentesfisicos}:


\begin{figure}[h]
	\includegraphics{componentesfisicosred.eps}
	\centering
	\caption{Componentes físicos de un sistema de distribución de agua \cite{Rossman2017}}
	\label{fig:componentesfisicos}
\end{figure}
\subsubsection{Nudos de caudal}

Son los puntos o extremos de una tubería, los cuales también permiten que estas se unan. Estos nudos pueden actuar como nudos de demanda a través de los cuales el flujo abandona la red.

\subsubsection{Embalse}
Es una fuente de alimentación externa.
\subsubsection{Deposito}
Son elementos con la capacidad de almacenar agua.
\subsubsection{Tubería}
 Son los elementos a través de los cuales transita el agua de un nudo a otro.
\subsubsection{Bomba}
Elementos que permiten impulsar el liquido con el fin de elevarlo a una posición superior.
\subsubsection{Válvula}
Elementos que limitan la presión o el caudal que transita en un punto de la red.
\subsection{Epanet}
Software que permite simular el comportamiento hidráulico y la calidad del agua en redes de distribución de aguas compuesta por tuberías, nodos, bombas, válvulas y tanques de almacenamiento \cite{Rossman2017}.  Este software cuenta también con una librería dinámica conocida bajo el nombre de Epanet Programming Toolkit, la cual cuenta con un conjunto de funciones para realizar simulaciones desde diferentes entornos de desarrollo como C, C++, VB, Java, etc \cite{Rossman1999}.
\section{Optimización}
La optimización consiste en maximizar o minimizar un conjunto de funciones que matemáticamente pueden ser expresadas de la siguiente forma:
$$f_1(x),f_2(x), ..., f_N(x),\ x=(x_1,...,x_d) | x \in X$$
sujeto a una serie de condiciones
$$h_j(x) = 0, j=1,2,...,J$$
$$g_k(x) \leq 0, k=1,2,...,K$$
siendo $f_1,...,f_N$ funciones objetivos; $x_1, ..., x_d$ variables de decisión, pertenecientes al espacio de búsqueda $X$; y $h_j$ junto con $g_k$, una serie de restricciones \cite{Yang2015}. De acuerdo a la cantidad de funciones objetivos que se tenga, se establece que si $N=1$ la optimización es \textbf{monoobjetivo}, mientras que para $N\geq 2$ se conoce como \textbf{multiobjetivo} \cite{Yang2015}. En este punto se debe tener en cuenta que los objetivos planteados deben encontrarse en contradicción. 

Debido a la definición de las restricciones es posible dividir el espacio de búsqueda en dos regiones \cite{Bozorg-Haddad2017}:
\begin{itemize}
	\item Soluciones factibles: Compuesto por los elementos pertenecientes al espacio de búsqueda que satisfacen todas las restricciones.
	\item Soluciones no factibles: Integrado por aquellos elementos que no complen todas las restricciones.
\end{itemize}
\section{Heurística}
Es el conocimiento que se tiene del problema el cual permite acotar la búsqueda de las soluciones en espacios de búsqueda de gran tamaño que hacen inviable la aplicación de técnicas deterministas por el costo de tiempo que implican. Con la utilización de estas técnicas se espera encontrar soluciones buenas en un tiempo razonable, pero esto no esta garantizado \cite{Yang2015,Romanycia1985}.
\section{Metaheurística}
Algoritmos que permiten resolver un amplio rango de problemas de optimización empleando técnicas con algún grado de aleatoriedad para encontrar soluciones a un problema. Estos algoritmos no garantizan que la solución encontrada sea la óptima, pero permiten obtener generalmente aproximaciones a esta. La diferencia entra heurísticas y metaheurísticas, es que esta ultima puede ser aplicado a un amplio conjunto de problemas sin necesidad de realizar grandes cambios en el algoritmo, mientras que las heurísticas generalmente son aplicadas a un dominio especifico \cite{Yang2015,Boussaid2013,Luke2013}.
\subsection{Algoritmos Evolutivos}
Conjunto de algoritmos inspirado en la teoría de la evolución de Darwin acerca de la capacidad de la naturaleza para evolucionar seres vivos bien adaptados a su entorno. Estos algoritmos hacen uso de diversos mecanismos entre los que se encuentra la selección, mutación y cruzamiento sobre los individuos de una población con el fin de generar una nueva generación de individuos \cite{Boussaid2013}. En la Figura \ref{fig:EA} muestra un un pseudocodigo de los pasos generales de un algoritmo evolutivo.


%\begin{figure}[h]
%	\begin{algorithm}[H]
%		\caption{Algoritmo Evolutivo}
%		\DontPrintSemicolon
%		\SetKwFunction{CreateInitialPopulation}{createInitialPopulation}
%		\SetKwFunction{EvaluatePopulation}{evaluatePopulation}
%		\SetKwFunction{Selection}{selection}
%		\SetKwFunction{Crossover}{crossover}
%		\SetKwFunction{Mutation}{mutation}
%		\SetKwFunction{Replace}{replace}
%		\SetKwData{PopulationVar}{population}
%		\SetKwData{SelectionVar}{selection}
%		\SetKwData{OffspringVar}{offspringPopulation}
%		
%		\PopulationVar $\leftarrow$ \CreateInitialPopulation{}\;
%		\EvaluatePopulation{\PopulationVar}\;
%		
%		\While{is not stopping condition reached}{
%			\SelectionVar $\leftarrow$ \Selection{\PopulationVar}\;
%			\OffspringVar $\leftarrow$ \Crossover{\SelectionVar}\;
%			\OffspringVar $\leftarrow$ \Mutation(\OffspringVar)\;
%			\OffspringVar $\leftarrow$ \EvaluatePopulation(\OffspringVar)\;
%			\PopulationVar $\leftarrow$ \Replace(\PopulationVar, \OffspringVar)\;
%		}
%		
%	\end{algorithm}
%	\caption{Pseudocodigo algoritmo evolutivo}
%	\label{fig:EA}
%\end{figure}

\begin{figure}[h]
	\begin{algorithm}[H]
		\caption{Algoritmo Evolutivo}
		\DontPrintSemicolon
		\SetKwFunction{CreateInitialPopulation}{crearPoblaciónInicial}
		\SetKwFunction{EvaluatePopulation}{evaluarPoblación}
		\SetKwFunction{Selection}{selección}
		\SetKwFunction{Crossover}{cruzamiento}
		\SetKwFunction{Mutation}{mutación}
		\SetKwFunction{Replace}{remplazar}
		\SetKwData{PopulationVar}{población}
		\SetKwData{SelectionVar}{poblacionSeleccionada}
		\SetKwData{OffspringVar}{poblaciónDecendiente}
		
		\PopulationVar $\leftarrow$ \CreateInitialPopulation{}\;
		\EvaluatePopulation{\PopulationVar}\;
		
		\While{la condición de termino no ha sido alcanzada}{
			\SelectionVar $\leftarrow$ \Selection{\PopulationVar}\;
			\OffspringVar $\leftarrow$ \Crossover{\SelectionVar}\;
			\OffspringVar $\leftarrow$ \Mutation(\OffspringVar)\;
			\OffspringVar $\leftarrow$ \EvaluatePopulation(\OffspringVar)\;
			\PopulationVar $\leftarrow$ \Replace(\PopulationVar, \OffspringVar)\;
		}
		
	\end{algorithm}
	\caption{Pseudocodigo algoritmo evolutivo}
	\label{fig:EA}
\end{figure}

Primero, se crea la población inicial. Luego, se evalúan los objetivos de dicha población y se itera hasta que la condición de termino haya sido alcanzada. La condición de término puede ser, por ejemplo un máximo numero de evaluaciones o evaluaciones sin mejoras en los resultados.  Dentro del ciclo se realiza la selección sobre la población con el fin de determinar las soluciones que serán usadas en los operadores de cruzamiento y mutación. Finalmente, se remplaza la población inicial con la descendiente.

\subsubsection{Población}
Conjunto de soluciones candidatas sobre las cual opera el algoritmo. Durante cada iteración del algoritmo se generan nuevas soluciones que son agregadas a la población a la vez que se remueven otras. Una solución en la población se conoce como individuo \cite{Heiss-Czedik1997}. 

Los individuos pueden ser representados de diversas maneras, entre ellas se encuentra la representación binaria (1 y 0), la real(Los números reales), etc. Para la representación binaria cada variable se codifica como un conjunto de bits, lo cual forma una cadena binaria. Por ejemplo, la representación binaria de la solución $(2,4,6,8)$ formada por enteros de 4 bits correspondería a

$$0010\ 0100\ 0110\ 1000$$


 En cambio, para la representación real esta se presenta como un vector, en donde cada valor que forma este vector pertenece a los números reales, es decir, $$v = (x1,x2, \dots, x_n), \textrm{en donde } v \in \mathbb{R}^n$$

\subsubsection{Selección}
La selección es un mecanismo utilizado por los algoritmos evolutivos para escoger a los individuos mas aptos los cuales serán usados para la reproducción \cite{Heiss-Czedik1997}. Existen numerosos algoritmos de selección que pueden ser utilizados en los algoritmos evolutivos.


\subsubsection{Cruzamiento}
El cruzamiento es un mecanismo usado para generar nuevos soluciones a partir de dos o mas individuos seleccionados \cite{Blum2003, Boussaid2013}.
\subsubsection{Mutación}
La mutación es un operador el cual permite mantener la diversidad en la descendencia \cite{Boussaid2013} realizando modificaciones en ciertas partes de la solución.

\subsection{Algoritmo Genético}
El algoritmo genético es una estrategia de búsqueda de soluciones. Para realizar esto, el algoritmo parte desde un conjunto de soluciones denominada población he iterativamente, lleva a cabo un proceso de reproducción, generando nuevas soluciones \cite{Heiss-Czedik1997}. Este algoritmo pertenece a la categoría de algoritmos evolutivos y por lo tanto puede usar el mismo esquema presentado en la Figura \ref{fig:EA}.

Los individuos en el contexto del algoritmo genético son llamados cromosomas, los cuales como se menciono en la sección de los algoritmos evolutivos pueden ser representados de diversas maneras.

\subsection{Conceptos para la optimización multiobjetivo}
Como resultado de un proceso de optimización multiobjetivo no existe una única solución a un problema, sino que se tiene un conjunto de soluciones. Es por ello que a continuación se presentaran una serie de criterios que permitirán analizar y determinar el conjunto de soluciones optimas. Los criterios son los siguientes \cite{VanVeldhuizen1998}:
 
\subsubsection{Dominancia de Pareto}

Sean $u$ y $v$ vectores pertenecientes a $\Re^n$, se dice que $u$ domina a $v$ (se denota como $u \preceq v$) si, y sólo si (en el caso de minimización):
$\forall i \in \{1,2,...,n\} | f_i(u) \leq f_i(v) \wedge \exists j \in \{1,2,...,n\} | f_j(u) < f_j(v)$

Es decir, para que una solución domine a otra, cada uno de sus objetivos debe ser mejores o iguales y al menos en uno de ellos este debe ser mejor.

En el ejemplo de la Figura \ref{fig:dominancia} se muestra los vectores A,B,C,D de los cuales C y B dominan a D, y A domina a C B y D. Nótese que C y B no son dominantes entre sí. 

\subsubsection{Optimo de Pareto}
Una solución $u$ es un optimo de Pareto si no hay otra solución $v$ en el espacio $\Omega$, tal que v domine a u, es decir, para $u , v \in \Re^n\ \  \nexists v \preceq u $. Los óptimos de pareto también se conocen bajo el nombre de solución no-dominada. En la Figura \ref{fig:dominancia} el vector A sería un optimo de Pareto.

\begin{figure}[h]
	\includegraphics{dominancia.eps}
	\centering
	\caption{Ejemplo de dominancia y óptimo de Pareto}
	\label{fig:dominancia}
\end{figure}

\subsubsection{Frontera de Pareto}
La frontera de Pareto es el conjunto de todas las soluciones no dominadas las cuales componen las soluciones óptimas al problema multiobjetivo. En la Figura \ref{fig:frente_pareto} los puntos rojos componen la frontera de Pareto.

\begin{figure}[h]
	\includegraphics{frontera-pareto.eps}
	\centering
	\caption{Ejemplo frente de Pareto}
	\label{fig:frente_pareto}
\end{figure}
\subsection{Algoritmo NSGA-II (Nondominated Genetic Algorithm)}
El algoritmo NSGA-II \cite{Deb2002} pertenece a la categoría de algoritmo evolutivo multiobjetivo (MOEA). Este algoritmo al igual que el algoritmo genético hace uso de los operadores de selección, cruzamiento y mutación para encontrar un conjunto de soluciones optimas a problemas que cuentan con más de un objetivo. Adicionalmente, NSGA-II añade conceptos y operadores adicionales los cuales permiten mejorar su rendimiento y la calidad de las soluciones obtenidas. NSGA-II puede ser implementado siguiendo los mismos pasos de el algoritmo evolutivo mostrados en la Figura \ref{fig:EA}, utilizando la función de remplazo mostrada en la Figura \ref{fig:RemplaceNSGAII}.

En la Figura \ref{fig:RemplaceNSGAII} se puede ver que el proceso de remplazo dentro del algoritmo genético consiste en unir la población actual y la población descendiente (formada por los elementos resultantes del operador de selección y sobre la que se han aplicado el cruzamiento y la mutación) en un solo elemento llamada unionPoblación. Luego, esta  es enviada a un procedimiento el cual ordena y categoriza la población en diversos frentes de acuerdo al concepto de dominancia de Pareto. Después, de que la población a sido categorizada se procede a iterar sobre los frentes y añadir sus elementos a una nueva población con el cuidado de no sobrepasar el tamaño de la población deseada ($N$). En caso de que uno de los frentes no pueda ser añadido en su totalidad por sobrepasar dicho tamaño, se llevará a cabo un proceso por el cual se ordenaran las soluciones en dicho frente basadas en un criterio conocido como densidad de las soluciones. Una vez realizado el ordenamiento, se agregarán las mejores soluciones a la nueva población hasta alcanzar el tamaño deseado  $N$. Se puede ver un ejemplo de este procedimiento gráficamente en la Figura \ref{fig:procedimientoNSGAII}.

% Una vez las soluciones se encuentren ordenadas se rellenará la nueva población hasta alcanzar el tamaño de deseado $N$. 

\begin{figure}[h]
	\begin{algorithm}[H]
		\caption{Función de remplazo para el algoritmo NSGA-II}
		\DontPrintSemicolon
		\SetKwData{PopulationVar}{población}
		\SetKwData{OffspringVar}{poblaciónDescendiente}
		\SetKwData{JoinVar}{unionPoblacion}
		\SetKwData{Front}{$F$}
		\SetKwData{NewPopulation}{nuevaPoblacion}

		\SetKwFunction{FastNonDominatingSorting}{ordenarPorFrentesNoDominados}
		\SetKwFunction{CrowdingDistanceAssignament}{asignarDensidad}
		\SetKwFunction{Sort}{ordernar}

		\SetKwProg{Fn}{Function}{}{fin}
		\Fn{remplazar(\PopulationVar, \OffspringVar)}{
		
		$\JoinVar \leftarrow \PopulationVar \cup \OffspringVar$\;
		\BlankLine
		\tcc*[h]{$F = (F_1,F_2, ...)$}\;
		\Front $\leftarrow$ \FastNonDominatingSorting(\JoinVar)\;
		\BlankLine
		\NewPopulation $\leftarrow \emptyset$ \;
		\BlankLine
		$i = 1$\;
		\BlankLine
		\tcc*[h]{Hasta que \NewPopulation este lleno}\;
		\While{$(|\NewPopulation| +|F_i|) \leq N$}{
			\tcc{Calcular y asignar la densidad a cada solución del frente $F_i$}
			\CrowdingDistanceAssignament($F_i$)\;
			\BlankLine
			\tcc{Añadir a \NewPopulation las soluciones del frente $F_i$}
			\NewPopulation $\leftarrow$ \NewPopulation $\cup$ $F_i$ \;
			\BlankLine
			$i = i+1$\;
		}
		\BlankLine
		\tcc{Ordenar el frente $F_i$ usando el comparador de densidad}
		\Sort($F_i$, $\prec_n$) \;
		\BlankLine
		\tcc{Elegir los primeros $N -|\NewPopulation|]$ }
		\NewPopulation $\leftarrow$ \NewPopulation $\cup$ $F_i[1: N -|\NewPopulation|]$ \;
		\BlankLine
		retornar \NewPopulation\;
	}
		
	\end{algorithm}
	\caption{Pseudocódigo de la función de remplazo utilizada en el algoritmo NSGA-II \cite{Deb2002}}
	\label{fig:RemplaceNSGAII}
\end{figure}


\begin{figure}[h]
	\includegraphics{ProcedimientoNSGA-II.eps}
	\centering
	\caption{Procedimiento NSGA-II \cite{Deb2002}}
	\label{fig:procedimientoNSGAII}
\end{figure}

A continuación se procederá a explicar los operadores adicionales presentados en \cite{Deb2002} y que son utilizados por la función de remplazo del algoritmo NSGA-II en la Figura \ref{fig:RemplaceNSGAII}.

\subsubsection{Ordenamiento de soluciones en frentes no dominados}
Uno de los procedimientos presentados en la Figura \ref{fig:RemplaceNSGAII} consiste en ordenar las soluciones en frentes no dominados. Los frentes no dominados son conjuntos en los que se almacenan las soluciones que no se dominan entre si. En la Figura \ref{fig:frente-no-dominados} se muestra un ejemplo con tres frentes.

\begin{figure}[h]
	\includegraphics{frentes-no-dominados.eps}
	\centering
	\caption{Frentes no dominados}
	\label{fig:frente-no-dominados}
\end{figure}

El algoritmo para llevar a cabo esto se presenta en la Figura \ref{fig:sortFront} y consiste en lo siguiente:

Primero, se debe comparar todas las soluciones entre si utilizando el concepto de dominancia de Pareto. Para ello, cada solución $p$ cuenta con un atributo $S_p$ en el que guarda todas las soluciones a las que domina y un contador $n_p$ que almacena el numero de soluciones que lo dominan a él. Cada vez que se termina de comparar una solución con todas las otras, si su contador $n_p$ es igual a 0, se le asigna a la solución el rango que indica el frente al que pertenece, y se guarda esta en un conjunto que contiene a todas las soluciones de dicho frente $F_1$. 
	
Una vez que se han identificado todas las soluciones no dominadas del primer frente se procede a generar el siguiente, para lo cual, por cada solución $q$ almacenada en el conjunto $S_p \in p$ del frente ya conocido se disminuye en uno su contador $n_q$. Si el contador $n_q$ de la solución $q$ llega a 0, entonces se le asigna a dicha solución el rango correspondiente y se guarda esta en un conjunto temporal $Q$ con el resto de las soluciones en dicho frente. Cuando se tengan identificadas todas las soluciones, estas se asignan al frente correspondiente $F_i$. 

Finalmente, se repite el procedimiento anterior sobre el nuevo frente hasta haberlos generado todos.


\begin{figure}[h]
	\begin{algorithm}[H]
		\caption{Función de ordenación en frentes no dominados}
		\DontPrintSemicolon
		\SetKwData{PopulationVar}{población}
		\SetKwData{Front}{$F$}
		\SetKwData{NewPopulation}{nuevaPoblacion}
		
		\SetKwFunction{FastNonDominatingSorting}{ordenarPorFrentesNoDominados}


		
		\SetKwProg{Fn}{Function}{}{fin}
		\Fn{\FastNonDominatingSorting(\PopulationVar)}{
		$\Front \leftarrow \emptyset$\;
		\ForEach{$p \in \PopulationVar$}{
			\tcc*[h]{Conjunto de soluciones dominadas por $p$}\;
			$S_p = \emptyset$\; 
			\tcc*[h]{Numeros de soluciones que dominan a $p$}\;
			$n_p = 0$\;
			\ForEach{$q \in \PopulationVar$}{
				\uIf(\tcc*[h]{$p$ domina a $q$}){$p \prec q$}{
					$S_p = S_p \cup \{q\}$\;
				}\ElseIf(\tcc*[h]{$q$ domina a $p$}){$q \prec p$}{
					$n_p = n_p + 1$\;
				}
				\If{$n_p = 0$}{
					$p_{rango} = 1$\;
					$F_1 = F_1 \cup \{p\}$\;
				}	
			}
		}
		\BlankLine
		$i = 1$\;
		\BlankLine
		\While{$F_i \neq 0$}{
			$Q = \emptyset$\;
			\ForEach{$p \in \Front_i$}{
				\ForEach{$q \in S_p$}{
					$n_q = n_q - 1$\;
					\If{$n_q = 0$}{
						$q_{rango} = i + 1$\;
						$Q = Q \cup \{q\}$\;
					}
				}
			}

			$i = i+1$\;
			$F_i = Q$\;
		}
		
		
		
	}
		
	\end{algorithm}
	\caption{Pseudocódigo de la función de ordenamiento utilizada en NSGA-II \cite{Deb2002}}
	\label{fig:sortFront}
\end{figure}

\subsubsection{Densidad de estimación (Crowing Distance)}
Otra función presente en la Figura \ref{fig:RemplaceNSGAII} es la asignación de las densidades sobre cada solución, la cual corresponde a la distancia promedio entre la solución anterior y la siguiente a partir de cada uno de los objetivos. En la Figura \ref{fig:crowdingDistance} la densidad de la solución $i$ corresponde a la suma de la longitud del lado mayor y del lado menor del rectángulo.

\begin{figure}[h]
	\includegraphics[scale=0.8]{crowing-distance.eps}
	\centering
	\caption{Calculo de la densidad de estimación al rededor de la solución $i$ \cite{Deb2002}.}
	\label{fig:crowdingDistance}
\end{figure}

El procedimiento para esta función  se muestra en la Figura \ref{fig:crowdingDistance} y consiste en:

Primero, crear e inicializar un arreglo $\mathcal{I}_{distancia}$, con el valor 0, en donde guardar las distancias para cada solución a medida que se van calculando. Luego, por cada uno de los objetivos se ordena el frente $\mathcal{I}$ y dentro $\mathcal{I}_{distancia}$ se le asigna al primer y ultimo elemento el valor infinito. Finalmente, se recorre desde la segunda hasta la penúltima solución calculando la distancia $\mathcal{I}[i]_{distancia}$. Notar que $f_m^{max}$ y $f_m^{min}$ corresponden al valor del objetivo $m$ de la primera y ultima solución.

\begin{figure}[h]
	\begin{algorithm}[H]
	\caption{Función de calculo de densidades}
	\DontPrintSemicolon
	\SetKwData{NDS}{$\mathcal{I}$}
	\SetKwFunction{CrowdingDistanceAssignament}{asignarDensidad}
		
		
		
	\SetKwProg{Fn}{Function}{}{fin}
	\Fn(\tcc*[h]{$\NDS$ : frente de soluciones no dominadas}){\CrowdingDistanceAssignament($\NDS$)}{
		$l = |\NDS|$ \tcc*[h]{Obtiene el tamaño del frente}\;\;
		\BlankLine
		\tcc*[h]{Inicializa la distancia para cada solución}\;
		\ForEach{$i \leftarrow 1$ \KwTo $l$}{
			$\NDS[i]_{distancia} \leftarrow 0$
		}
		\ForEach{$m \leftarrow 1$ \KwTo numero de objetivos}{
			$\NDS \leftarrow$ sort($\NDS$, m) \tcc*[h]{Ordena por el objetivo m}\; 
			\BlankLine
			\tcc*[h]{Asignar a la primera y ultima solucion el valor $\infty$ }\;
			$\NDS[1]_{distancia} \leftarrow \NDS[l]_{distancia} \leftarrow \infty$\;
			\BlankLine
			\For{$i \leftarrow 2$ \KwTo $l-1$}{
				\tcc*[h]{Asigna la distancia a las soluciones restantes}\;
				$\NDS[i]_{distancia} \leftarrow \NDS[i]_{distancia} + (\NDS[i+1].m - \NDS[i-1].m)/(f_m^{max} - f_m^{min})$\;	
			}
		}
	
	}
		
	\end{algorithm}
	\caption{Pseudocódigo de la función de asignación de densidad \cite{Deb2002}}
	\label{fig:CrowindDistance}
\end{figure}
\subsubsection{Comparador de densidad (Crowing Distance comparator)}
Este operador compara las soluciones basados en dos conceptos los cuales son el rango de dominación y la densidad de soluciones. Estos fueron calculados al momento de generar los frentes y asignar la densidad a las soluciones. De acuerdo a Deb \cite{Deb2002}, se define el orden dado por el operador de densidad ($\prec_n$) como: $i \prec_n j $, si $(i_{rango} < j_{rango})$ o $((i_{rango} = j_{rango})$ o $(i_{distancia} > j_{distancia}))$.

%% contenido del tercer capítulo
\chapter{Metodología}
Durante este capitulo se explicara la razón por la que fue escogida esta metodología sobre todas las demás existentes y como esta sera adaptada para ser llevada a cabo durante el desarrollo del proyecto.

Debido a que la metodología esta pensada para ser llevada a cabo por un equipo de trabajo se adaptará la metodología para poder ser aplicada en el desarrollo llevado a cabo por una sola persona. Esta adaptación consiste en la disminución de la cantidad de la documentación generada, permitir llevar a cabo más de una fase de la iteración al mismo tiempo y los roles de analista, diseñador, implementador y tester sera realizado por una sola persona. Los documentos a generar por cada fase serán:

\paragraph{Análisis:} El producto generado por esta fase sera un documento de especificación de requisitos que constara de:
\begin{itemize}
	\item Introducción: En este apartado del documento se hará una introducción al problema que se ha identificado.
	\item Requisitos de usuario: Consiste en la recopilación de lo requisitos de los usuarios que deben ser cumplidos al final del periodo de desarrollo.
	\item Requisito de sistema: Son los requisitos, desde un punto de vista mas técnico, que son necesarios para satisfacer los requisitos de usuario.
	\item Matriz de trazado requisitos de usuario vs sistema: Matriz que permite ver la trazabilidad de los requisitos de usuario con los de sistema.
\end{itemize}
\paragraph{Diseño:} Esta fase generara como producto un documento de diseño que contara con los siguientes diagramas:
\begin{itemize}
	\item Casos de uso: Serie de diagramas que permiten ver la interacción que el usuario tendrá con el sistema.
	\item Arquitectura lógica: Descripción a alto nivel del software y los componentes que lo componen.
	\item Diagrama de componentes: Permite ver la división del sistema y la interacción entre los distintos componentes \cite{Bell2004}.
	\item Diagrama de clases: Describe la relación entre las distintas clases presentes en la solución propuesta.
\end{itemize}
\paragraph{Implementación:} Esta fase generara el código fuente de la aplicación y un manual de usuario de la aplicación.
\paragraph{Pruebas:} Durante esta fase de realizaran la documentación y la realización de las pruebas sobre la aplicación.
\begin{itemize}
	\item Se documentará las pruebas unitarias realizadas y sobre que componentes.
	\item Se documentará las pruebas de integración y que caso de uso cubren.
\end{itemize}

La razón por la que se utilizará esta metodología sobre otras es porque el producto resultante de este proyecto esta pensado para servir como base para futuros trabajos. Debido a esto es necesario documentar correctamente para que otros programadores puedan continuar con su desarrollo más adelante. Aunque existen otras metodologías como cascada u otras tradicionales, estas son difíciles de llevar a cabo por la cantidad de documentación que se requiere, mientras que metodologías de desarrollo ágil carecen en cuanto a la documentación que se necesita para el sistema a desarrollar. Además, esta metodología nos permite obtener una retroalimentación al final de la iteración, obtener nuevos requisitos que no hayan quedado definidos en etapas anteriores o refinar los requisitos y el diseño ya existente, permitiendo así mejorar la calidad del producto final.

La implementación de esta metodología para el desarrollo del proyecto se llevará a cabo repartiendo las tareas necesarias para el cumplimiento de los objetivos en iteraciones. De este modo al final de cada iteración se contará con un prototipo funcional de la aplicación sobre el que se agregaran las nuevas funcionalidades en las iteraciones siguientes.

%% contenido del cuarto capítulo
\chapter{Evaluación De La Solución}
%% contenido del quinto capítulo
\chapter{Conclusiones Y Trabajos Futuros}
%% ambiente glosario
\begin{glosario}
  \item[El primer término:] Este es el significado del primer término, realmente no se bien lo que significa pero podría haberlo averiguado si hubiese tenido un poco mas de tiempo.
  \item[El segundo término:] Este si se lo que significa pero me da lata escribirlo...
\end{glosario}


%% genera las referencias
\bibliography{refs}


%% comienzo de la parte de anexos
\appendixpart

%% contenido del primer anexo
\appendix{Documento de especificación de requisitos}



%% contenido del segundo anexo
\appendix{Documento de diseño}

%\includepdf[pages=-]{Documentodedisenio.pdf}

\appendix{Documento de casos de prueba}

\appendix{Cuestionario para la evaluación de la aplicación}
%% fin
\end{document}

   

