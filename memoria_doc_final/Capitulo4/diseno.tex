\section{Diseño}

Una vez terminada la fase de requisitos se procede a diseñar la aplicación. Dentro del diseño, se encuentran las tareas de escoger  y documentar la arquitectura física y lógica, realizar los diagramas de clases, diagramas de secuencia, diseño de interfaces, entre otros.

Mientras avanzaba el desarrollo fue necesario ir modificando el documento de diseño debido a la aparición o al cambio de requisitos, así como la realización de mejoras en los diagramas realizados. En el Cuadro~\ref{fig:cambios_diseno} se presentan más detalladamente los cambios realizados en cada iteración.

\begin{table}
  \begin{center}
    \caption{Actividades y cambios en la fase de diseño durante cada iteración}
    \begin{tabular}{||c| m{6cm}| m{6cm}||} 
      \hline
      N° Iteración & Tareas & Comentario\\ [0.5ex] 
      \hline\hline
      1 & Crear arquitectura lógica. \newline Crear arquitectura física. \newline Diseñar módulos.\newline Crear diagrama de clases del modulo metaheurística. \newline Crear diagrama de clases del la representación de la red.
      & Durante esta iteración se creo el documento de diseño y se crearon los esquemas básicos para orientar la construcción del software.\\
      \hline
      2 & No hubieron cambios & No hubieron cambios en esta iteración en el aspecto del diseño.\\
      \hline
      3 & Diseñar interfaces de usuario.\newline Especificar detalles de la implementación referente a las anotaciones de Java (\textit{Java Annotations}) y \textit{Java Reflection}.\newline Generar diagrama de secuencia de optimización. & Durante esta fase de diseñaron algunas de las interfaces de usuario de la aplicación. \newline Los diagramas de secuencia creados indican la interacción entre las clases para poder realizar una tarea.\\
      \hline
      4 & No hubieron cambios & No hubieron cambios en esta iteración en el aspecto del diseño.\\
      \hline
      5 & Modificar interfaces de usuario. \newline Crear diagrama de secuencia para realizar la simulación usando las configuraciones por defecto. Modificar y mejora del diagrama de secuencia de la optimización. & Debido a requisitos del usuario en el área de usabilidad de la aplicación fue necesario modificar las interfaces.\\
      \hline
      6 & Modificar y mejora del diagrama de secuencia de la optimización. & Se modifico el diagrama de secuencia de la optimización debido a la aparición de un nuevo requisito.  \\
      \hline
    \end{tabular}
    \label{fig:cambios_diseno}
  \end{center}
\end{table}

Como una de las primeras tareas realizadas durante esta fase se procedió a definir la arquitectura de la aplicación, tanto desde el punto físico como el lógico. 

La arquitectura física del programa a desarrollar es la arquitectura monolítica, cuya característica es que software que posee esta arquitectura funciona localmente sin necesidad de interactuar con otros equipos. Esta elección se debe a que en reuniones con el cliente se estableció que el programa será usado localmente y debe operar sobre el sistema operativo Windows. Limitación debida principalmente al acceso a funciones nativas cuando se realizan simulaciones hidráulicas utilizando la  librería dinámica de Epanet. La Figura~\ref{fig:arq_fisica} muestra el diagrama de la arquitectura monolítica.

\begin{figure}[h]
  \includegraphics[width=0.5\textwidth]{Capitulo4/assets/arquitectura_fisica.png}
  \centering
  \caption{Arquitectura física monolítica}
  \label{fig:arq_fisica}
\end{figure}

En cuanto a la arquitectura lógica se escogió utilizar Modelo-Vista-Controlador. Ésta elección es debido al hecho de que dicha arquitectura nos permite separar la capa de interfaz de usuario de la lógica de la aplicación mejorando asi escalabilidad y mantenibilidad del software. La Figura~\ref{fig:arq_logica} muestra el diagrama de la arquitectura lógica, así como los principales módulos de la aplicación.

\begin{figure}[h]
  \includegraphics[width=\textwidth]{Capitulo4/assets/arquitectura_logica.eps}
  \centering
  \caption{Arquitectura lógica Modelo-Vista-Controlador}
  \label{fig:arq_logica}
\end{figure}

A continuación se presentarán los diseños relaciónados por cada una de las funcionalidades escogidas con anterioridad.

\paragraph{Funcionalidad 1:} Para implementar esta funcionalidad es necesario abstraer en un conjunto de clases los datos almacenados en el archivo de configuración de red. La Figura~\ref{fig:dia_clase_network} muestra el diagrama de clases reducido (se dejan fuera varias clases que especifican las configuraciones generales de la red) de la estructura sobre la que se almacenan los datos al momento de cargar la red. La clase \textit{Network} actúa como un contenedor para las demás clases presentes en el diagrama.


\begin{figure}[h]
  \centering
  \includegraphics[width=\textheight, angle=90]{Capitulo4/assets/d_clases_network.eps}
  \caption{Diagrama de clases de la abstracción de la red reducido.}
  \label{fig:dia_clase_network}
\end{figure}

El diagrama de la Figura~\ref{fig:dia_sec_visualizacion} muestra el conjunto de clases y los mensajes de la clases que interactúan con la clase \textit{Network} con el fin de visualizar la red. 

\begin{figure}[h]
  \centering
  \includegraphics[height=\textwidth, angle=90]{Capitulo4/assets/d_sec_visualizacion.eps}
  \caption{Diagrama de secuencia de la carga y visualización de la red}
  \label{fig:dia_sec_visualizacion}
\end{figure}

\paragraph{Funcionalidad 2:} Esta es una de las funcionalidades ligada al modulo metaheurística y debido a uno de los requisitos establecidos por el cliente de que la aplicación debe poder extender el número de algoritmos, operadores y problemas implementados es necesario implementar una jerarquía de clases que facilite lo anteriormente mencionado. Es por ello, que se utilizo como base la jerarquía de clases utilizada por el Framework JMetal~\cite{Durillo2010} la cual fue adaptada para ser ocupada por esta aplicación. La Figura~\ref{fig:dia_class_met} corresponde a la jerarquía ya mencionada.


\begin{figure}[h]
  \centering
  \includegraphics[height=\textwidth, angle=90]{Capitulo4/assets/d_clases_metaheuristica.eps}
  \caption[Diagrama de clases modulo metaheurística.]{Diagrama de clases modulo metaheurística. Modificación a partir del diagrama presentado en~\cite{Durillo2010}}
  \label{fig:dia_class_met}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Debido a la importancia que tienen las metaheurísticas para la aplicación, se explicará de manera general que realiza cada una de las clases e interfaces presentes en la Figura~\ref{fig:dia_class_met}.

\textit{\textbf{Algorithm}} es la interfaz desde la que se heredan, ya sea directa o indirectamente, cada uno de los algoritmos metaheurísticos implementados por la aplicación. Su principal método es \textit{runASingleStep} puesto que éste permite realiza una única iteración del algoritmo, permitiendo así que el programa interactué con la instancia del algoritmo. Esta interacción permite recuperar los resultados intermedios de la optimización, así como también cancelar la ejecución. Un ejemplo de la implementación de este método para GA se muestra en la Figura~\ref{fig:runSingleStep}.

\begin{figure}[h]
  \begin{lstlisting}
int step = 0;
List<IntegerSolution> population;
public void runSingleStep() throws Exception, EpanetException {
  List<S> offspringPopulation;
  List<S> selectionPopulation;

  // Durante la primera iteración inicializa 
  // y evalúa la población
  if (step == 0) {
    population = createInitialPopulation();
    population = evaluatePopulation(population);
    initProgress();
  }
  // Desde la segunda iteración en adelante selecciona
  // y reproduce las soluciones
  if (!isStoppingConditionReached()) {
    selectionPopulation = selection(population);
    offspringPopulation = reproduction(selectionPopulation);
    offspringPopulation = evaluatePopulation(offspringPopulation);
    population = replacement(population, offspringPopulation);
    updateProgress();
  }

  this.step++;
}
  \end{lstlisting}
  \caption{Código del método \textit{runSingleStep} utilizado con GA y NSGAII}
  \label{fig:runSingleStep}
\end{figure}

\textit{\textbf{Solution}} es la interfaz que representa la solución del problema. La aplicación implementa esta interfaz en una clase llamada \textit{IntegerSolution}, la cual permite trabajar variables de decisión de tipo entero.

\textit{\textbf{Operator}} es la interfaz de la que heredan todos los tipos de operadores usado en la aplicación. Los operadores son clases que contienen una función que trabaja sobre una o un conjunto de soluciones. Sus usos son muy variables, entre ellos se encuentra la selección de soluciones dentro de un conjunto, la modificación de las variables de decisión de una solución y la combinación de dos soluciones con el fin de generar unas nuevas.

\textit{\textbf{Problem}} es la interfaz de la que heredan todos los problemas. Las clases que implementan esta interfaz son las que se encargan de evaluar y penalizar las soluciones generadas por los algoritmos metaheurísticos en el método \textit{evaluate}. Adicionalmente, esta clase es usada para mapear una solución sobre la red cargada y de esta manera poder generar un nuevo archivo de configuración de red. El método que realiza esto ultimo es \textit{applySolutionToNetwork}.

Las clases \textit{\textbf{ExperimentAlgorithm}} y \textit{\textbf{ExperimentProblem}} actúan como envoltorios para las clases \textit{Algorithm} y \textit{Problem} incorporando algunas funciones adicionales.

Por ultimo la clase \textit{\textbf{Experiment}} es un contenedor de algoritmos. Cada algoritmo agregado al experimento corresponde a una iteración independiente. Actualmente, se pensaron los experimentos para solo contener varias instancias de un mismo algoritmo. Los algoritmos deben ser acoplados a un \textit{ExperimentAlgorithm} antes de ser agregados al Experimento.

Cada una de las clases explicadas anteriormente tiene un bajo acoplamiento entre ellas, así como del resto de la aplicación puesto que se hace uso de la técnica llamada Polimorfismo. Esto permite combinar cada una de ellas de diferentes maneras, por ejemplo, se pueden usar distintos algoritmos para el mismo tipo de problema. La limitación de esto es que el problema debe ser compatible con el algoritmo, es decir, si el algoritmo esta diseñado para ser monoobjetivo, entonces el problema debe tener un solo objetivo.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

El diagrama de secuencia de la Figura~\ref{fig:dia_sec_opt} muestra la interacción de las clases con del modulo metaheurísticas, con el resto de clases de la aplicación.


\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{Capitulo4/assets/d_seq_simulacion-monomulti.eps}
  \caption{Diagrama de secuencia para llevar a cabo la optimizacion de los problemas}
  \label{fig:dia_sec_opt}
\end{figure}

\paragraph{Funcionalidad 3:} Para implementar esta funcionalidad es necesario implementar un conjunto de clases las cuales guardarán los resultados de la simulación para cada uno de los nodos y enlaces de una red. Estas nuevas clases son las mostradas en la Figura~\ref{fig:dia_class_sim_hyd}.


\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{Capitulo4/assets/d_clases_hyd_simulation.eps}
  \caption{Diagrama de clases para la simulación hidráulica}
  \label{fig:dia_class_sim_hyd}
\end{figure}

El diagrama de secuencia presentado en la Figura~\ref{fig:dia_sec_sim_hyd} muestra la interacción entre las clases necesarias para realizar la simulación hidráulica utilizando los valores del archivo de red cargado.

\begin{figure}[h]
  \centering
  \includegraphics[height=\textwidth, angle=90]{Capitulo4/assets/d_seq_simulacion-hidraulica.eps}
  \caption{Diagrama de secuencia para realizar la simulación hidráulica}
  \label{fig:dia_sec_sim_hyd}
\end{figure}

\subsection{Detalles de implementación}

%% Extensibilidad
En diferentes secciones de este documento se ha mencionado que la aplicación debe ser extensible, refiriéndonos al hecho de que se deben poder agregar nuevos algoritmos, operadores y problemas. Una vez alcanzada la tercera iteración fue necesario hacer frente a este problema. Sin embargo, éste no es un problema fácil de abordar. Las ideas que surgieron para tratar este problema eran diversas. Una de ellas, por ejemplo, consistía en que el usuario una vez haya creado un nuevo problema; implementara por si mismo la interfaz de configuración para éste y la integrara a la aplicación. No obstante, realizar ésta tarea consistía en que se debía tener conocimiento de la implementación de interfaces gráficas usando JavaFX, así como conocer el código de la aplicación para realizar cambios sobre este. Al momento de crear un nuevo algoritmo u operador también estaba presente este problema porque si el usuario quería poner a disposición un nuevo algoritmo para resolver el problema debía realizar cambios en el código de la aplicación.
  
Finalmente se decidió utilizar un enfoque parecido al de los frameworks de Java Spring y JUnit utilizando las técnicas o patrones de diseño de inyección de dependencias e inversión de control. 

El sistema define un flujo de trabajo. En el programa se puede agregar un nuevo problema simplemente definiendo una nueva clase que es usada como plantilla para crear los nuevos experimentos de un problema con un algoritmo especifico. Esta nueva clase debe heredar de una de las subclases de \textit{Registrable}. La jerarquía de herencia de la clase \textit{Registrable} se muestra en la Figura~\ref{fig:registrable}. En dicha clase se pueden usar anotaciones en el constructor para definir los tipos de las instancias a inyectar asi como los valores de configuración que necesita el experimento. En este caso los tipos corresponden a los operadores a utilizar en el algoritmo del experimento a configurar. El flujo que sigue la aplicación se presenta en la Figura~\ref{fig:diagrama_actividades}. Durante ``Configurar Experimento'' se leen las anotaciones para construir la interfaz gráfica, una vez configurado el experimento en esta interfaz se crean e inyectan las dependencias al momento de crear la instancia de \textit{Registrable} usando la \textit{Java Reflection API}.

\begin{figure}[h]
    \centering
    \includegraphics[height=0.9\textheight]{Capitulo4/assets/d_actividad.eps}
    \caption[Diagrama de actividades de la aplicación]{Diagrama de actividades de la aplicación}
    \label{fig:diagrama_actividades}
\end{figure}

Las anotaciones permitidas en la interfaz \textit{Registrable} que se definieron son las siguientes:

\begin{description}
  \item[\textit{@NewProblem}:] Esta anotación permite indicar el nombre del problema y el algoritmo utilizado para resolverlo.
  \item[\textit{@Parameters}:] Esta anotación permite agregar información acerca de los parámetros recibidos por el constructor. Esta anotación permite concatenar anotaciones.
  \begin{description}
    \item[\textit{@OperatorInput}:] Indica que se espera recibir un operador. Se utiliza \textit{@OperatorOption} para indicar los posibles operadores que pueden ser inyectados.
    \begin{description}
      \item[\textit{@OperatorOption}:]  Indica un posible operador para ser utilizado dentro del algoritmo.
    \end{description}
    \item[\textit{@FileInput}:] Indica que se espera recibir una ruta a un archivo. El archivo recibido puede contener valores para configurar el algoritmo.
    \item[\textit{@NumberInput}:] Indica que se espera recibir un número (el tipo de este número lo indica el parametro en el constructor). Este número puede ser por ejemplo el número de iteraciones del algoritmo, etc.
    \item[\textit{@NumberToggleInput}:]  Permite crear grupos de entradas númericas excluyentes entre si. Por ejemplo, si solo se puede configurar uno de los dos parámetros, ya sea el número de generaciones o el número de iteraciones sin mejora.
  \end{description}
\end{description}

Estas anotaciones deben estar sobre el constructor publico de la clase \textit{Registrable}.

Los operadores también pueden hacer uso de anotaciones. Las anotaciones permitidas para los operadores es:
\begin{description}
  \item[\textit{@DefaultConstructor}:] Esta anotación indica el constructor por defecto del operador que sera utilizado para inyectar los valores. Dentro de esta anotación se puede usar \textit{@NumberInput} para definir los parámetros que pueden ser inyectados al operador.
\end{description}

La aplicación leyendo las anotaciones presentadas anteriormente, construye una interfaz de usuario que se abre al momento de querer resolver el problema registrado.


% Esta clase actuá como una plantilla para crear nuevos experimentos. Junto con esta jerarquía se definieron un conjunto de anotaciones que son leídas durante la ejecución del problema al querer optimizar una red y son utilizadas para construir la interfaz gráfica y posteriormente inyectar en el constructor de la clase al crear la instancia las configuraciones y operadores a utilizar para la optimización.

% que Esto es, crear anotaciones que puedan ser leídas en tiempo de ejecución por el programa. Las anotaciones creadas permiten indicar los valores que se pueden configurar del problema, asi como los operadores a ser utilizados por un algoritmo. Las anotaciones son leídas desde el programa al momento de querer optimizar una RDA, permitiendo de esa manera construir dinamicamente una interfaz de usuario para configurar los detalles del algoritmo, operador y el problema a resolver. Finalmente, una vez configurados todos los detalles anteriormente mencionados, haciendo uso de \textit{Java Reflection} se crea una nueva instancia.

% , además de la modularidad proporcionada descrita por el diagrama de clases de la Figura \ref{fig:dia_class_met}, presentado para la Funcionalidad 2, se hace uso de una interfaz desde la cual se permiten definir plantillas para crear nuevos experimentos y acoplarlos a la aplicación. Dicha interfaz se muestra en la Figura~\ref{fig:registrable}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{Capitulo4/assets/d_class_registrable.eps}
    \caption{Interfaz de clase \textit{Registrable}.}
    \label{fig:registrable}
\end{figure}

En el \textbf{Anexo~\ref{appendix:diseno}} se puede ver la el documento de diseño de la aplicación.

\clearpage